"""Managing of user data

The data of the users are stored in the users directory (by default).

The file names are the identifiers of the users.

A new user identifier is generated by finding the maximal value of the identifiers and increasing by one.

The fields of a user object stored in the text file line-by-line as:

    first_name
    family_name
    birth
    email
    password

"""

import re
from datetime import date


class User(object):
    """User of the document repository"""

    def __init__(self, first_name, family_name, birth, email, password):
        self.first_name = first_name
        self.family_name = family_name
        self.birth = birth
        self.email = email
        self.password = password

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if value:
            self._first_name = value
        else:
            raise ValueError("First name must not be empty.")

    @property
    def family_name(self):
        return self._family_name

    @family_name.setter
    def family_name(self, value):
        if value:
            self._family_name = value
        else:
            raise ValueError("Family name must not be empty.")

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        if not value:
            raise ValueError("Birth date must not be empty.")
        elif type(value) == date:
            self._birth = value
        else:
            raise TypeError("Birth date must be in date format.")

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        pattern = "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]{2,4}$"
        if not value:
            raise ValueError("Email must not be empty.")
        if re.search(pattern, value):
            self._email = value
        else:
            raise ValueError("Email format is invalid.")

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, value):
        if value:
            self._password = value
        else:
            raise ValueError("Password must not be empty.")
